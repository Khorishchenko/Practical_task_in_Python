# Об’єктно-орієнтоване програмування (ООП) в Python

# Об’єкт — це будь-яка сутність, яка має атрибути (дані) та поведінку (методи/функції). Наприклад, кошеня — це об’єкт. В нього є:

#    атрибути — ім’я, вік, колір тощо.

#    поведінка — бігає, нявкає, спить і т.д.

# Клас — це креслення (план) цього об’єкта.


# Клас та об’єкти в Python
class Cat:
    # Атрибути (дані) класу
    name = ""
    age = 0
 
# Створення об'єкта cat1
cat1 = Cat()
cat1.name = "Blu"
cat1.age = 10
 
# Створення іншого об'єкта — cat2
cat2 = Cat()
cat2.name = "Woo"
cat2.age = 15
 
# Доступ до атрибутів класу Cat
print(f"{cat1.name} is {cat1.age} years old")
print(f"{cat2.name} is {cat2.age} years old")









# Спадкування в Python
# Спадкування — це спосіб створення нового класу, використовуючи дані вже існуючого класу без внесення змін до нього. 
# Створюваний клас є дочірнім (або “похідним”) класом, а існуючий клас є батьківським (або “базовим”) класом.

# Батьківський клас
class Animal:
    
    def eat(self):
        print( "I can eat!")
    
    def sleep(self):
        print("I can sleep!")
 
# Дочірній клас
class Dog(Animal):
    
    def bark(self):
        print("I can bark! Woof woof!!")
 
# Створюємо об'єкт класу Dog
dog1 = Dog()
 
# Викликаємо методи батьківського класу
dog1.eat()
dog1.sleep()
 
# Викликаємо метод дочірнього класу
dog1.bark()




# У Python self — це перший параметр методів класу, що використовується для посилання на поточний екземпляр класу.
# Він дозволяє методам отримувати доступ до атрибутів і інших методів цього конкретного екземпляра. 
# Тобто, використовуючи self, можна змінювати або отримувати дані, які належать до цього екземпляра класу

class Product:
    def __init__(self, price):
        self.__maxprice = price  # self.__maxprice вказує, що це атрибут об'єкта класу

    def get_price(self):
        return self.__maxprice

    def set_price(self, price):
        self.__maxprice = price  # Тут self використовується для зміни значення атрибута

# Створюємо екземпляр класу Product
product = Product(900)

# Отримуємо значення
print(product.get_price())  # Виведе: 900

# Змінюємо значення
product.set_price(1000)
print(product.get_price())  # Виведе: 1000




# У цьому прикладі:

# self.__maxprice — це атрибут екземпляра класу.
# Ключове слово self дозволяє звертатися до цього атрибута та методів усередині класу.


# Атрибут екземпляра класу означає, що це змінна, яка належить кожному окремому екземпляру 
# (об'єкту) класу. Іншими словами, кожен об'єкт класу може мати власне значення цього атрибута,
#   яке може відрізнятися від значення в іншому об'єкті того ж класу.


# У Python атрибути, оголошені як `self.model = model`, є **відкритими (публічними)**. Це означає, що до них можна отримати доступ і змінювати їх ззовні класу без жодних обмежень.
# Якщо ви хочете зробити атрибут **закритим (приватним)**, його назву потрібно починати з двох підкреслень, наприклад:

# ```python
class Car:
    def __init__(self, model, year):
        self.__model = model  # Приватний атрибут
        self.__year = year    # Приватний атрибут
# ```

# Такі атрибути не можна безпосередньо змінювати або отримувати до них доступ ззовні класу:

# ```python
car = Car("Tesla Model S", 2022)
print(car.__model)  # Це викличе помилку AttributeError
# ```

# Проте Python дозволяє отримати доступ до таких атрибутів через "механізм манглінгу імен" (наприклад, через `_Car__model`), тому це більше рекомендація, ніж повна заборона.

# ### Висновок:
# - `self.model = model` — атрибут **відкритий** (public).
# - `self.__model = model` — атрибут **закритий** (private).




















# Інкапсуляція в Python
# Інкапсуляція — це об’єднання атрибутів і методів всередині класу, яке запобігає доступу зовнішніх класів до атрибутів і методів даного класу та їх зміні. 
# Іншими словами, це “приховування даних”.

# В Python приватні (private) атрибути позначаються за допомогою одинарного _ або подвійного __ підкреслень розміщених на місці префіксу. Наприклад:
class Computer:
    def __init__(self):
        self.__maxprice = 900
 
    def sell(self):
        print("Selling Price: {}".format(self.__maxprice))
 
    def setMaxPrice(self, price):
        self.__maxprice = price
 
c = Computer()
c.sell()
 
# Змінюємо ціну
c.__maxprice = 1000 # не змінне, інкапсульована - хоча помилки на компілюванні не має. Відсутня помилка.
c.sell()
 
# Використовуємо функцію-сеттер
c.setMaxPrice(1000)
c.sell()





# Поліморфізм в Python
# Поліморфізм означає наявність більш як однієї форми, тобто одна і та ж сутність (метод, оператор чи об’єкт) може виконувати різні дії у різних ситуаціях. Наприклад:

class Polygon:
    # Метод рендерингу полігону
    def render(self):
        print("Rendering Polygon...")
 
class Square(Polygon):
    # Метод рендерингу квадрата
    def render(self):
        print("Rendering Square...")
 
class Circle(Polygon):
    # Метод рендерингу кола
    def render(self):
        print("Rendering Circle...")
    
# Створюємо об'єкт класу Square
s1 = Square()
s1.render()
 
# Створюємо об'єкт класу Circle
c1 = Circle()
c1.render()